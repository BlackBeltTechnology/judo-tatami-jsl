@abstract
rule AbstractViewGroupDeclaration
    transform s: JSL!UIViewGroupDeclaration
    to t: UI!ui::Flex {
        t.name = s.name;
        t.label = s.getLabelWithNameFallback();
        if (s.getIconModifier().isDefined()) {
            t.icon = s.equivalent("GroupIcon");
        }

        if (s.getFrame().isDefined() and s.getFrame().isTrue()) {
            t.frame = s.equivalent("GroupFrame");
        }

        if (s.getStretchModifier().isDefined() and s.getStretchModifier().isTrue()) {
            t.stretch = UI!ui::Stretch#BOTH;
        }

        t.col = s.getWidth().isDefined() ? s.getWidth().value.asReal() : 12d;
        t.~pos = s.getPos();

        if (s.getOrientationModifier().isDefined()) {
            t.direction = s.getOrientationModifier().isVertical() ? UI!Axis#VERTICAL : UI!Axis#HORIZONTAL;
        } else {
            t.direction = UI!Axis#VERTICAL;
        }

        if (t.direction == UI!Axis#VERTICAL) {
            if (s.getVAlign().isDefined() and s.getVAlign().isCenter()) {
                t.mainAxisAlignment = UI!ui::MainAxisAlignment#CENTER;
            } else if (s.getVAlign().isDefined() and s.getVAlign().isBottom()) {
                t.mainAxisAlignment = UI!ui::MainAxisAlignment#END;
            } else {
                t.mainAxisAlignment = UI!ui::MainAxisAlignment#START;
            }
            if (s.getHAlign().isDefined() and s.getHAlign().isCenter()) {
                t.crossAxisAlignment = UI!ui::CrossAxisAlignment#CENTER;
            } else if (s.getHAlign().isDefined() and s.getHAlign().isRight()) {
                t.crossAxisAlignment = UI!ui::CrossAxisAlignment#END;
            } else {
                t.crossAxisAlignment = UI!ui::CrossAxisAlignment#START;
            }
        } else {
            if (s.getHAlign().isDefined() and s.getHAlign().isCenter()) {
                t.mainAxisAlignment = UI!ui::MainAxisAlignment#CENTER;
            } else if (s.getHAlign().isDefined() and s.getHAlign().isRight()) {
                t.mainAxisAlignment = UI!ui::MainAxisAlignment#END;
            } else {
                t.mainAxisAlignment = UI!ui::MainAxisAlignment#START;
            }
            if (s.getVAlign().isDefined() and s.getVAlign().isCenter()) {
                t.crossAxisAlignment = UI!ui::CrossAxisAlignment#CENTER;
            } else if (s.getVAlign().isDefined() and s.getVAlign().isBottom()) {
                t.crossAxisAlignment = UI!ui::CrossAxisAlignment#END;
            } else {
                t.crossAxisAlignment = UI!ui::CrossAxisAlignment#START;
            }
        }
}

rule GroupVisualElement
    transform s: JSL!UIViewGroupDeclaration
    to t: UI!ui::Flex
    extends AbstractViewGroupDeclaration {
        guard: rootMenu.containsVisualElement(s)

        t.setId(rootMenu.name + "/(jsl/" + s.getId() + ")/GroupVisualElement");

        if (not s.eContainer.isKindOf(JSL!UIViewTabsDeclaration)) {
            var holder = t;
            if (s.isFrame()) {
                holder.frame = s.equivalent("GroupFrame");

            }
            s.eContainer.uiContainer().children.add(holder);
        }

        log.debug("Flex: " + t.name);
}

@lazy
@greedy
rule GroupFrame
    transform s: JSL!UIViewGroupDeclaration
    to t: UI!ui::Frame {
        t.setId(rootMenu.name + "/(jsl/" + s.getId() + ")/GroupFrame");
}

@lazy
@greedy
rule GroupIcon
    transform s: JSL!UIViewGroupDeclaration
    to t: UI!ui::Icon {
        t.iconName = s.getIconModifier().value.value;
        t.name = s.name + "GroupIcon";
        t.setId(rootMenu.name + "/(jsl/" + s.getId() + ")/GroupIcon");
}

@greedy
rule TabGroup
    transform s: JSL!UIViewGroupDeclaration
    to t: UI!ui::Tab {
        guard: s.eContainer.isKindOf(JSL!UIViewTabsDeclaration) and rootMenu.containsVisualElement(s)

        s.eContainer.equivalent("TabBarVisualElement").tabs.add(t);
        t.element = s.equivalent("GroupVisualElement");
        t.name = t.element.name;
        t.setId(rootMenu.name + "/(jsl/" + s.getId() + ")/TabGroup");

        log.debug("TabGroup: " + t.name);
}
